
Objects/main.o:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 3e 00 	jmp	0x7c	; 0x7c <__ctors_end>
   4:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
   8:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
   c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  10:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  14:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  18:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  1c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  20:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  24:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  28:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  2c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  30:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  34:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  38:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  3c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  40:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  44:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  48:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  4c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  50:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  54:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  58:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  5c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  60:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  64:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  68:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  6c:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  70:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  74:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>
  78:	0c 94 5b 00 	jmp	0xb6	; 0xb6 <__bad_interrupt>

0000007c <__ctors_end>:
  7c:	11 24       	eor	r1, r1
  7e:	1f be       	out	0x3f, r1	; 63
  80:	cf ef       	ldi	r28, 0xFF	; 255
  82:	d8 e0       	ldi	r29, 0x08	; 8
  84:	de bf       	out	0x3e, r29	; 62
  86:	cd bf       	out	0x3d, r28	; 61

00000088 <__do_copy_data>:
  88:	11 e0       	ldi	r17, 0x01	; 1
  8a:	a0 e0       	ldi	r26, 0x00	; 0
  8c:	b1 e0       	ldi	r27, 0x01	; 1
  8e:	e0 ec       	ldi	r30, 0xC0	; 192
  90:	f2 e0       	ldi	r31, 0x02	; 2
  92:	02 c0       	rjmp	.+4      	; 0x98 <__do_copy_data+0x10>
  94:	05 90       	lpm	r0, Z+
  96:	0d 92       	st	X+, r0
  98:	a4 30       	cpi	r26, 0x04	; 4
  9a:	b1 07       	cpc	r27, r17
  9c:	d9 f7       	brne	.-10     	; 0x94 <__do_copy_data+0xc>

0000009e <__do_clear_bss>:
  9e:	21 e0       	ldi	r18, 0x01	; 1
  a0:	a4 e0       	ldi	r26, 0x04	; 4
  a2:	b1 e0       	ldi	r27, 0x01	; 1
  a4:	01 c0       	rjmp	.+2      	; 0xa8 <.do_clear_bss_start>

000000a6 <.do_clear_bss_loop>:
  a6:	1d 92       	st	X+, r1

000000a8 <.do_clear_bss_start>:
  a8:	a4 33       	cpi	r26, 0x34	; 52
  aa:	b2 07       	cpc	r27, r18
  ac:	e1 f7       	brne	.-8      	; 0xa6 <.do_clear_bss_loop>
  ae:	0e 94 bf 00 	call	0x17e	; 0x17e <main>
  b2:	0c 94 5e 01 	jmp	0x2bc	; 0x2bc <_exit>

000000b6 <__bad_interrupt>:
  b6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ba <checkPress>:
struct cRGB led[16];
unsigned char noteOn = 144;
unsigned char noteOff = 128;
unsigned char baseVelocity = 100;

void checkPress(int PAx, int PCx) {
  ba:	1f 93       	push	r17
  bc:	cf 93       	push	r28
  be:	df 93       	push	r29
    // Set PCx to ground
    PORTC &= ~(1 << PCx);
  c0:	28 b1       	in	r18, 0x08	; 8
  c2:	c1 e0       	ldi	r28, 0x01	; 1
  c4:	d0 e0       	ldi	r29, 0x00	; 0
  c6:	06 2e       	mov	r0, r22
  c8:	01 c0       	rjmp	.+2      	; 0xcc <checkPress+0x12>
  ca:	cc 0f       	add	r28, r28
  cc:	0a 94       	dec	r0
  ce:	ea f7       	brpl	.-6      	; 0xca <checkPress+0x10>
  d0:	3c 2f       	mov	r19, r28
  d2:	30 95       	com	r19
  d4:	23 23       	and	r18, r19
  d6:	28 b9       	out	0x08, r18	; 8
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
  d8:	25 e0       	ldi	r18, 0x05	; 5
  da:	2a 95       	dec	r18
  dc:	f1 f7       	brne	.-4      	; 0xda <checkPress+0x20>
  de:	00 00       	nop
    _delay_us(1);

    int led_idx;
    if (PAx == 0 || PAx == 2) {
  e0:	ac 01       	movw	r20, r24
  e2:	4d 7f       	andi	r20, 0xFD	; 253
  e4:	9c 01       	movw	r18, r24
  e6:	22 0f       	add	r18, r18
  e8:	33 1f       	adc	r19, r19
  ea:	22 0f       	add	r18, r18
  ec:	33 1f       	adc	r19, r19
  ee:	45 2b       	or	r20, r21
  f0:	19 f4       	brne	.+6      	; 0xf8 <checkPress+0x3e>
        led_idx = PAx * 4 + PCx;
  f2:	62 0f       	add	r22, r18
  f4:	73 1f       	adc	r23, r19
  f6:	06 c0       	rjmp	.+12     	; 0x104 <checkPress+0x4a>
    } else {
        led_idx = PAx * 4 + (3 - PCx);
  f8:	a9 01       	movw	r20, r18
  fa:	46 1b       	sub	r20, r22
  fc:	57 0b       	sbc	r21, r23
  fe:	ba 01       	movw	r22, r20
 100:	6d 5f       	subi	r22, 0xFD	; 253
 102:	7f 4f       	sbci	r23, 0xFF	; 255
    }
    char note = led_idx + 1;
 104:	11 e0       	ldi	r17, 0x01	; 1
 106:	16 0f       	add	r17, r22

    // Check if button is pressed
    if(!(PINA & (1 << PAx))) {  // Light up the led
 108:	20 b1       	in	r18, 0x00	; 0
 10a:	30 e0       	ldi	r19, 0x00	; 0
 10c:	a9 01       	movw	r20, r18
 10e:	02 c0       	rjmp	.+4      	; 0x114 <checkPress+0x5a>
 110:	55 95       	asr	r21
 112:	47 95       	ror	r20
 114:	8a 95       	dec	r24
 116:	e2 f7       	brpl	.-8      	; 0x110 <checkPress+0x56>
 118:	ca 01       	movw	r24, r20
 11a:	fb 01       	movw	r30, r22
 11c:	ee 0f       	add	r30, r30
 11e:	ff 1f       	adc	r31, r31
        led[led_idx].b = 100;
 120:	6e 0f       	add	r22, r30
 122:	7f 1f       	adc	r23, r31
 124:	fb 01       	movw	r30, r22
 126:	ec 5f       	subi	r30, 0xFC	; 252
 128:	fe 4f       	sbci	r31, 0xFE	; 254
        led_idx = PAx * 4 + (3 - PCx);
    }
    char note = led_idx + 1;

    // Check if button is pressed
    if(!(PINA & (1 << PAx))) {  // Light up the led
 12a:	80 fd       	sbrc	r24, 0
 12c:	0b c0       	rjmp	.+22     	; 0x144 <checkPress+0x8a>
        led[led_idx].b = 100;
 12e:	84 e6       	ldi	r24, 0x64	; 100
 130:	82 83       	std	Z+2, r24	; 0x02
        ws2812_setleds(led, 16);
 132:	60 e1       	ldi	r22, 0x10	; 16
 134:	70 e0       	ldi	r23, 0x00	; 0
 136:	84 e0       	ldi	r24, 0x04	; 4
 138:	91 e0       	ldi	r25, 0x01	; 1
 13a:	0e 94 13 01 	call	0x226	; 0x226 <ws2812_setleds>

        USART0_transmit(noteOn);
 13e:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <noteOn>
 142:	09 c0       	rjmp	.+18     	; 0x156 <checkPress+0x9c>
        USART0_transmit(note);
        USART0_transmit(baseVelocity);
    } else {
        led[led_idx].b = 0;
 144:	12 82       	std	Z+2, r1	; 0x02
        ws2812_setleds(led, 16);
 146:	60 e1       	ldi	r22, 0x10	; 16
 148:	70 e0       	ldi	r23, 0x00	; 0
 14a:	84 e0       	ldi	r24, 0x04	; 4
 14c:	91 e0       	ldi	r25, 0x01	; 1
 14e:	0e 94 13 01 	call	0x226	; 0x226 <ws2812_setleds>

        USART0_transmit(noteOff);
 152:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <noteOff>
 156:	0e 94 3b 01 	call	0x276	; 0x276 <USART0_transmit>
        USART0_transmit(note);
 15a:	81 2f       	mov	r24, r17
 15c:	0e 94 3b 01 	call	0x276	; 0x276 <USART0_transmit>
        USART0_transmit(baseVelocity);
 160:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
 164:	0e 94 3b 01 	call	0x276	; 0x276 <USART0_transmit>
    }

    // Reset PCx to vcc
    PORTC |= (1 << PCx);
 168:	88 b1       	in	r24, 0x08	; 8
 16a:	c8 2b       	or	r28, r24
 16c:	c8 b9       	out	0x08, r28	; 8
 16e:	55 e3       	ldi	r21, 0x35	; 53
 170:	5a 95       	dec	r21
 172:	f1 f7       	brne	.-4      	; 0x170 <checkPress+0xb6>
 174:	00 00       	nop
    _delay_us(10);
}
 176:	df 91       	pop	r29
 178:	cf 91       	pop	r28
 17a:	1f 91       	pop	r17
 17c:	08 95       	ret

0000017e <main>:

int main(void) {

 // configurare porturi folosite
    DDRB &= ~(1 << PB2);
 17e:	22 98       	cbi	0x04, 2	; 4
    PORTB |= (1 << PB2);
 180:	2a 9a       	sbi	0x05, 2	; 5

    DDRA &= ~((1 << PA0) | (1 << PA1) | (1 << PA2) | (1 << PA3));
 182:	81 b1       	in	r24, 0x01	; 1
 184:	80 7f       	andi	r24, 0xF0	; 240
 186:	81 b9       	out	0x01, r24	; 1
    PORTA |= (1 << PA0) | (1 << PA1) | (1 << PA2) | (1 << PA3);    // Citirea (cu rezistenta de pullup)
 188:	82 b1       	in	r24, 0x02	; 2
 18a:	8f 60       	ori	r24, 0x0F	; 15
 18c:	82 b9       	out	0x02, r24	; 2

    DDRC |= (1 << PC0) | (1 << PC1) | (1 << PC2) | (1 << PC3);  // Scrierea
 18e:	87 b1       	in	r24, 0x07	; 7
 190:	8f 60       	ori	r24, 0x0F	; 15
 192:	87 b9       	out	0x07, r24	; 7
    PORTC |= ((1 << PC0) | (1 << PC1) | (1 << PC2) | (1 << PC3));  // toate sunt pe vcc initial
 194:	88 b1       	in	r24, 0x08	; 8
 196:	8f 60       	ori	r24, 0x0F	; 15
 198:	88 b9       	out	0x08, r24	; 8

    // Initializare seriala
    USART0_init();
 19a:	0e 94 27 01 	call	0x24e	; 0x24e <USART0_init>

	// int8_t PB2_flag = 0;
	while (1) {
        // Loop through the buttons and check if pressed
        for (int i = PA0; i <= PA3; i++) {
 19e:	00 e0       	ldi	r16, 0x00	; 0
 1a0:	10 e0       	ldi	r17, 0x00	; 0
    // Reset PCx to vcc
    PORTC |= (1 << PCx);
    _delay_us(10);
}

int main(void) {
 1a2:	c0 e0       	ldi	r28, 0x00	; 0
 1a4:	d0 e0       	ldi	r29, 0x00	; 0
	// int8_t PB2_flag = 0;
	while (1) {
        // Loop through the buttons and check if pressed
        for (int i = PA0; i <= PA3; i++) {
            for (int j = PC0; j <= PC3; j++) {
                checkPress(i, j);
 1a6:	be 01       	movw	r22, r28
 1a8:	c8 01       	movw	r24, r16
 1aa:	0e 94 5d 00 	call	0xba	; 0xba <checkPress>

	// int8_t PB2_flag = 0;
	while (1) {
        // Loop through the buttons and check if pressed
        for (int i = PA0; i <= PA3; i++) {
            for (int j = PC0; j <= PC3; j++) {
 1ae:	21 96       	adiw	r28, 0x01	; 1
 1b0:	c4 30       	cpi	r28, 0x04	; 4
 1b2:	d1 05       	cpc	r29, r1
 1b4:	c1 f7       	brne	.-16     	; 0x1a6 <main+0x28>
    USART0_init();

	// int8_t PB2_flag = 0;
	while (1) {
        // Loop through the buttons and check if pressed
        for (int i = PA0; i <= PA3; i++) {
 1b6:	0f 5f       	subi	r16, 0xFF	; 255
 1b8:	1f 4f       	sbci	r17, 0xFF	; 255
 1ba:	04 30       	cpi	r16, 0x04	; 4
 1bc:	11 05       	cpc	r17, r1
 1be:	89 f7       	brne	.-30     	; 0x1a2 <main+0x24>
 1c0:	ee cf       	rjmp	.-36     	; 0x19e <main+0x20>

000001c2 <ws2812_sendarray_mask>:
void inline ws2812_sendarray_mask(uint8_t *data,uint16_t datlen,uint8_t maskhi)
{
  uint8_t curbyte,ctr,masklo;
  uint8_t sreg_prev;
  
  ws2812_DDRREG |= maskhi; // Enable output
 1c2:	24 b1       	in	r18, 0x04	; 4
 1c4:	24 2b       	or	r18, r20
 1c6:	24 b9       	out	0x04, r18	; 4
  
  masklo	=~maskhi&ws2812_PORTREG;
 1c8:	25 b1       	in	r18, 0x05	; 5
 1ca:	34 2f       	mov	r19, r20
 1cc:	30 95       	com	r19
 1ce:	23 23       	and	r18, r19
  maskhi |=        ws2812_PORTREG;
 1d0:	35 b1       	in	r19, 0x05	; 5
 1d2:	43 2b       	or	r20, r19
  
  sreg_prev=SREG;
 1d4:	3f b7       	in	r19, 0x3f	; 63
  cli();  
 1d6:	f8 94       	cli
 1d8:	fc 01       	movw	r30, r24
 1da:	68 0f       	add	r22, r24
 1dc:	79 1f       	adc	r23, r25

  while (datlen--) {
 1de:	e6 17       	cp	r30, r22
 1e0:	f7 07       	cpc	r31, r23
 1e2:	89 f0       	breq	.+34     	; 0x206 <loop24+0x1e>
    curbyte=*data++;
 1e4:	81 91       	ld	r24, Z+
    
    asm volatile(
 1e6:	98 e0       	ldi	r25, 0x08	; 8

000001e8 <loop24>:
 1e8:	45 b9       	out	0x05, r20	; 5
 1ea:	00 00       	nop
 1ec:	00 c0       	rjmp	.+0      	; 0x1ee <loop24+0x6>
 1ee:	87 ff       	sbrs	r24, 7
 1f0:	25 b9       	out	0x05, r18	; 5
 1f2:	88 0f       	add	r24, r24
 1f4:	00 00       	nop
 1f6:	00 c0       	rjmp	.+0      	; 0x1f8 <loop24+0x10>
 1f8:	00 c0       	rjmp	.+0      	; 0x1fa <loop24+0x12>
 1fa:	00 c0       	rjmp	.+0      	; 0x1fc <loop24+0x14>
 1fc:	25 b9       	out	0x05, r18	; 5
 1fe:	00 c0       	rjmp	.+0      	; 0x200 <loop24+0x18>
 200:	9a 95       	dec	r25
 202:	91 f7       	brne	.-28     	; 0x1e8 <loop24>
 204:	ec cf       	rjmp	.-40     	; 0x1de <ws2812_sendarray_mask+0x1c>
    :	"=&d" (ctr)
    :	"r" (curbyte), "I" (_SFR_IO_ADDR(ws2812_PORTREG)), "r" (maskhi), "r" (masklo)
    );
  }
  
  SREG=sreg_prev;
 206:	3f bf       	out	0x3f, r19	; 63
 208:	08 95       	ret

0000020a <ws2812_setleds_pin>:
   ws2812_setleds_pin(ledarray,leds, _BV(ws2812_pin));
}

void inline ws2812_setleds_pin(struct cRGB *ledarray, uint16_t leds, uint8_t pinmask)
{
  ws2812_sendarray_mask((uint8_t*)ledarray,leds+leds+leds,pinmask);
 20a:	9b 01       	movw	r18, r22
 20c:	22 0f       	add	r18, r18
 20e:	33 1f       	adc	r19, r19
 210:	62 0f       	add	r22, r18
 212:	73 1f       	adc	r23, r19
 214:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <ws2812_sendarray_mask>
 218:	87 ec       	ldi	r24, 0xC7	; 199
 21a:	90 e0       	ldi	r25, 0x00	; 0
 21c:	01 97       	sbiw	r24, 0x01	; 1
 21e:	f1 f7       	brne	.-4      	; 0x21c <ws2812_setleds_pin+0x12>
 220:	00 c0       	rjmp	.+0      	; 0x222 <ws2812_setleds_pin+0x18>
 222:	00 00       	nop
 224:	08 95       	ret

00000226 <ws2812_setleds>:
#include <util/delay.h>
 
// Setleds for standard RGB 
void inline ws2812_setleds(struct cRGB *ledarray, uint16_t leds)
{
   ws2812_setleds_pin(ledarray,leds, _BV(ws2812_pin));
 226:	40 e8       	ldi	r20, 0x80	; 128
 228:	0c 94 05 01 	jmp	0x20a	; 0x20a <ws2812_setleds_pin>

0000022c <ws2812_setleds_rgbw>:
}

// Setleds for SK6812RGBW
void inline ws2812_setleds_rgbw(struct cRGBW *ledarray, uint16_t leds)
{
  ws2812_sendarray_mask((uint8_t*)ledarray,leds<<2,_BV(ws2812_pin));
 22c:	66 0f       	add	r22, r22
 22e:	77 1f       	adc	r23, r23
 230:	66 0f       	add	r22, r22
 232:	77 1f       	adc	r23, r23
 234:	40 e8       	ldi	r20, 0x80	; 128
 236:	0e 94 e1 00 	call	0x1c2	; 0x1c2 <ws2812_sendarray_mask>
 23a:	87 ec       	ldi	r24, 0xC7	; 199
 23c:	90 e0       	ldi	r25, 0x00	; 0
 23e:	01 97       	sbiw	r24, 0x01	; 1
 240:	f1 f7       	brne	.-4      	; 0x23e <ws2812_setleds_rgbw+0x12>
 242:	00 c0       	rjmp	.+0      	; 0x244 <ws2812_setleds_rgbw+0x18>
 244:	00 00       	nop
 246:	08 95       	ret

00000248 <ws2812_sendarray>:
  _delay_us(ws2812_resettime);
}

void ws2812_sendarray(uint8_t *data,uint16_t datlen)
{
  ws2812_sendarray_mask(data,datlen,_BV(ws2812_pin));
 248:	40 e8       	ldi	r20, 0x80	; 128
 24a:	0c 94 e1 00 	jmp	0x1c2	; 0x1c2 <ws2812_sendarray_mask>

0000024e <USART0_init>:
 * Functie de initializare a controllerului USART
 */
void USART0_init()
{
    /* seteaza baud rate la 9600 */
    UBRR0H = 0;
 24e:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
    UBRR0L = 103;
 252:	87 e6       	ldi	r24, 0x67	; 103
 254:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>

    /* porneste transmitatorul */
    UCSR0B = (1<<TXEN0) | (1<<RXEN0);
 258:	88 e1       	ldi	r24, 0x18	; 24
 25a:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>

    /* seteaza formatul frame-ului: 8 biti de date, 1 biti de stop, paritate para */
    UCSR0C &= ~(1<<USBS0);
 25e:	e2 ec       	ldi	r30, 0xC2	; 194
 260:	f0 e0       	ldi	r31, 0x00	; 0
 262:	80 81       	ld	r24, Z
 264:	87 7f       	andi	r24, 0xF7	; 247
 266:	80 83       	st	Z, r24
    UCSR0C |= (2<<UCSZ00);
 268:	80 81       	ld	r24, Z
 26a:	84 60       	ori	r24, 0x04	; 4
 26c:	80 83       	st	Z, r24
    UCSR0C |= (1<<UPM01);
 26e:	80 81       	ld	r24, Z
 270:	80 62       	ori	r24, 0x20	; 32
 272:	80 83       	st	Z, r24
 274:	08 95       	ret

00000276 <USART0_transmit>:
 * @param data - caracterul de transmis
 */
void USART0_transmit(char data)
{
    /* asteapta pana bufferul e gol */
    while(!(UCSR0A & (1<<UDRE0)));
 276:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
 27a:	95 ff       	sbrs	r25, 5
 27c:	fc cf       	rjmp	.-8      	; 0x276 <USART0_transmit>

    /* pune datele in buffer; transmisia va porni automat in urma scrierii */
    UDR0 = data;
 27e:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
 282:	08 95       	ret

00000284 <USART0_receive>:
 * @return - caracterul primit
 */
char USART0_receive()
{
    /* asteapta cat timp bufferul e gol */
    while(!(UCSR0A & (1<<RXC0)));
 284:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
 288:	87 ff       	sbrs	r24, 7
 28a:	fc cf       	rjmp	.-8      	; 0x284 <USART0_receive>

    /* returneaza datele din buffer */
    return UDR0;
 28c:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
}
 290:	08 95       	ret

00000292 <USART0_print>:
 * Functie ce transmite un sir de caractere prin USART
 *
 * @param data - sirul (terminat cu '\0') de transmis
 */
void USART0_print(const char *data)
{
 292:	cf 93       	push	r28
 294:	df 93       	push	r29
 296:	ec 01       	movw	r28, r24
    while(*data != '\0')
 298:	89 91       	ld	r24, Y+
 29a:	88 23       	and	r24, r24
 29c:	19 f0       	breq	.+6      	; 0x2a4 <USART0_print+0x12>
        USART0_transmit(*data++);
 29e:	0e 94 3b 01 	call	0x276	; 0x276 <USART0_transmit>
 2a2:	fa cf       	rjmp	.-12     	; 0x298 <USART0_print+0x6>
}
 2a4:	df 91       	pop	r29
 2a6:	cf 91       	pop	r28
 2a8:	08 95       	ret

000002aa <USART0_printf>:
 * @return - intotdeauna returneaza 0
 */
int USART0_printf(char data, FILE *stream)
{
    /* asteapta pana bufferul e gol */
    while(!(UCSR0A & (1<<UDRE0)));
 2aa:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
 2ae:	95 ff       	sbrs	r25, 5
 2b0:	fc cf       	rjmp	.-8      	; 0x2aa <USART0_printf>

    /* pune datele in buffer; transmisia va porni automat in urma scrierii */
    UDR0 = data;
 2b2:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    return 0;
}
 2b6:	80 e0       	ldi	r24, 0x00	; 0
 2b8:	90 e0       	ldi	r25, 0x00	; 0
 2ba:	08 95       	ret

000002bc <_exit>:
 2bc:	f8 94       	cli

000002be <__stop_program>:
 2be:	ff cf       	rjmp	.-2      	; 0x2be <__stop_program>
